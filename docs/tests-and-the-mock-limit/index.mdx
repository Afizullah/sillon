---
hide_table_of_contents: true
---

# Les tests et la limite du mock

Nous ne sommes pas pour imposer des tests √† tous les niveaux et sur tout votre code applicatif. Il est beaucoup plus important selon nous de :

- D√©montrer que votre produit sert r√©ellement en r√©pondant aux besoins utilisateurs (et donc en d√©veloppant des fonctionnalit√©s) ;
- D'avoir un maximum de flexibilit√© dans la maintenance de votre outil, car m√™me en testant, il vous arrivera des p√©pins auxquels vous n'auriez jamais pens√©s.

Essayez de focaliser vos tests unitaires sur des briques critiques qui g√®rent de la donn√©e m√©tier (validation d'un num√©ro de t√©l√©phone, g√©n√©ration d'une URL sign√©e pour un fichier‚Ä¶). Apr√®s si vous √™tes √† l'aise et efficace avec le [TDD](https://fr.wikipedia.org/wiki/Test_driven_development) ou le [BDD](https://en.wikipedia.org/wiki/Behavior-driven_development), bien entendu il faut continuer les pratiques qui marchent üòâ.

_De toute fa√ßon avec le temps votre pourcentage de couverture en tests va progresser, il est probable qu'√† chaque bug remont√© il soit plus facile de le tester de mani√®re isol√©e de l'applicatif (impliquant de faire des tests unitaires pour facilement d√©bugger)._

Par contre, quand on veut tester √† un niveau plus abstrait on se retrouve souvent √† faire des mocks qui ne veulent plus rien dire puisqu'on les a fait sp√©cifiquement pour que le test concern√© passe. Par exemple, si l'on veut tester un code qui a des interactions avec la base de donn√©es, on peut essayer de mocker la base, mais √ßa ne nous dira jamais si finalement la requ√™te de jointure ou les `SELECT` imbriqu√©s auraient march√© dans une vraie situation. Il existe pourtant bien quelques librairies qui essaient de faire "database in memory" mais √ßa ne reste qu'une pseudo-copie o√π vous n'aurez pas les vraies probl√©matiques de l'outil.

:::tip
Si vous souhaitez faire des tests d'int√©gration, nous pr√©conisons de faire des tests en restant local √† votre code, avec toute la logique dans votre test (comme pour des tests unitaires). Pour cela nous utilisons [`test-containers`](https://github.com/testcontainers/testcontainers-node) qui va communiquer avec votre Docker local pour peupler de fa√ßon √©ph√©m√®re par exemple une PostgreSQL, un [`mailcatcher`](https://hub.docker.com/r/aerzas/mailcatcher)‚Ä¶ afin de faire des tests qui reproduisent un minimum l'environnement de production. Comme l'image d'un container est en cache apr√®s le premier test, peupler un container prend √† peine quelques secondes et cela devient totalement transparent.

Le processus marche aussi dans les CI/CD (en tout cas sur GitHub Actions) puisque le runner Docker est disponible via son API HTTP, donc vos tests sont en mesure de dire √† la pipeline "peuple un container, puis √©teins-le". Plus besoin de sp√©cifier en dur dans la pipeline les potentielles d√©pendances de services üôå.
:::
